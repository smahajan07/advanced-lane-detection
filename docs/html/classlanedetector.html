<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Advanced Lane Detection: lanedetector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Advanced Lane Detection
   </div>
   <div id="projectbrief">Using C++ and OpenCV</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlanedetector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lanedetector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac600737bb1e17700b37abdfd9bb73b06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#ac600737bb1e17700b37abdfd9bb73b06">lanedetector</a> ()</td></tr>
<tr class="memdesc:ac600737bb1e17700b37abdfd9bb73b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the private members of the class.  <a href="#ac600737bb1e17700b37abdfd9bb73b06">More...</a><br /></td></tr>
<tr class="separator:ac600737bb1e17700b37abdfd9bb73b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968acbf150b7e935953c340a2cf38542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a968acbf150b7e935953c340a2cf38542">lanedetector</a> (bool, bool, double, double, cv::Point, cv::Point, double, double)</td></tr>
<tr class="memdesc:a968acbf150b7e935953c340a2cf38542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the private members of the class.  <a href="#a968acbf150b7e935953c340a2cf38542">More...</a><br /></td></tr>
<tr class="separator:a968acbf150b7e935953c340a2cf38542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c096187d507d6f3e623b9c7a471459"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#ae1c096187d507d6f3e623b9c7a471459">undistortImage</a> (cv::Mat, cv::Mat, cv::Mat)</td></tr>
<tr class="memdesc:ae1c096187d507d6f3e623b9c7a471459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Due to radial distortion, straight lines appear as curved.  <a href="#ae1c096187d507d6f3e623b9c7a471459">More...</a><br /></td></tr>
<tr class="separator:ae1c096187d507d6f3e623b9c7a471459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d92c01545c5c9713c9a70d5903ce181"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a4d92c01545c5c9713c9a70d5903ce181">preprocessImage</a> (cv::Mat)</td></tr>
<tr class="memdesc:a4d92c01545c5c9713c9a70d5903ce181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denoise or smoothen image by applying a Gaussian filter.  <a href="#a4d92c01545c5c9713c9a70d5903ce181">More...</a><br /></td></tr>
<tr class="separator:a4d92c01545c5c9713c9a70d5903ce181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b977cb614d19ffa5e56f1b3ef3e8c9"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a90b977cb614d19ffa5e56f1b3ef3e8c9">grayImage</a> (cv::Mat)</td></tr>
<tr class="memdesc:a90b977cb614d19ffa5e56f1b3ef3e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a BGR image (three channels) to grayscale (single channel)  <a href="#a90b977cb614d19ffa5e56f1b3ef3e8c9">More...</a><br /></td></tr>
<tr class="separator:a90b977cb614d19ffa5e56f1b3ef3e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830dfaa616e20b5e15f8846fa8660eb"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a8830dfaa616e20b5e15f8846fa8660eb">detectEdges</a> (cv::Mat)</td></tr>
<tr class="memdesc:a8830dfaa616e20b5e15f8846fa8660eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect edges in an gray scale image. Since the ultimate objective.  <a href="#a8830dfaa616e20b5e15f8846fa8660eb">More...</a><br /></td></tr>
<tr class="separator:a8830dfaa616e20b5e15f8846fa8660eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82eab5e0a1d126018c99875b2486d5e"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#ab82eab5e0a1d126018c99875b2486d5e">extractROI</a> (cv::Mat, cv::Rect)</td></tr>
<tr class="memdesc:ab82eab5e0a1d126018c99875b2486d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a region of interest from an image  <a href="#ab82eab5e0a1d126018c99875b2486d5e">More...</a><br /></td></tr>
<tr class="separator:ab82eab5e0a1d126018c99875b2486d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea27c43dbcf8444f5c2b23dd6e4bb6d"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#abea27c43dbcf8444f5c2b23dd6e4bb6d">createMask</a> (cv::Mat)</td></tr>
<tr class="memdesc:abea27c43dbcf8444f5c2b23dd6e4bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask the image so that only a certain portion of the image has active.  <a href="#abea27c43dbcf8444f5c2b23dd6e4bb6d">More...</a><br /></td></tr>
<tr class="separator:abea27c43dbcf8444f5c2b23dd6e4bb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6433369cb584d5c247fe1a00569d17d5"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a6433369cb584d5c247fe1a00569d17d5">perspectiveTransform</a> (cv::Mat)</td></tr>
<tr class="memdesc:a6433369cb584d5c247fe1a00569d17d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warping an image to get a top view or bird's eye view. To improve.  <a href="#a6433369cb584d5c247fe1a00569d17d5">More...</a><br /></td></tr>
<tr class="separator:a6433369cb584d5c247fe1a00569d17d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d588d6b85384ad237e6fbfdf679591"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Vec4i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a10d588d6b85384ad237e6fbfdf679591">detectLanes</a> (cv::Mat)</td></tr>
<tr class="memdesc:a10d588d6b85384ad237e6fbfdf679591"><td class="mdescLeft">&#160;</td><td class="mdescRight">detects straight lines in a given image  <a href="#a10d588d6b85384ad237e6fbfdf679591">More...</a><br /></td></tr>
<tr class="separator:a10d588d6b85384ad237e6fbfdf679591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7506555f481f184276a4180c200a73"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a7d7506555f481f184276a4180c200a73">drawLines</a> (cv::Mat, std::vector&lt; cv::Vec4i &gt;)</td></tr>
<tr class="memdesc:a7d7506555f481f184276a4180c200a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for debugging. Draws lines on top of an image.  <a href="#a7d7506555f481f184276a4180c200a73">More...</a><br /></td></tr>
<tr class="separator:a7d7506555f481f184276a4180c200a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714784d2ef657578c3b8bbef5aeb3dd4"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a714784d2ef657578c3b8bbef5aeb3dd4">drawLines</a> (cv::Mat, std::vector&lt; cv::Vec4i &gt;, std::vector&lt; cv::Vec4i &gt;)</td></tr>
<tr class="memdesc:a714784d2ef657578c3b8bbef5aeb3dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for debugging. Draws lines on top of an image.  <a href="#a714784d2ef657578c3b8bbef5aeb3dd4">More...</a><br /></td></tr>
<tr class="separator:a714784d2ef657578c3b8bbef5aeb3dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03607a04461f6f9137a2d97297266d82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a03607a04461f6f9137a2d97297266d82">drawPolygon</a> (cv::Mat, std::vector&lt; cv::Point &gt;, std::string)</td></tr>
<tr class="memdesc:a03607a04461f6f9137a2d97297266d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the detected lane with a colored polygon for better.  <a href="#a03607a04461f6f9137a2d97297266d82">More...</a><br /></td></tr>
<tr class="separator:a03607a04461f6f9137a2d97297266d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9086075ddbe4827f473ce7105c1c27"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; cv::Vec4i &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a1b9086075ddbe4827f473ce7105c1c27">sortLanes</a> (std::vector&lt; cv::Vec4i &gt;, cv::Mat)</td></tr>
<tr class="memdesc:a1b9086075ddbe4827f473ce7105c1c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects only valid lines from all detected lines and sorts them.  <a href="#a1b9086075ddbe4827f473ce7105c1c27">More...</a><br /></td></tr>
<tr class="separator:a1b9086075ddbe4827f473ce7105c1c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70feae4d9119d7288b54bd7ea79ffb47"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a70feae4d9119d7288b54bd7ea79ffb47">computeFitLine</a> (std::vector&lt; std::vector&lt; cv::Vec4i &gt;&gt;, cv::Mat)</td></tr>
<tr class="memdesc:a70feae4d9119d7288b54bd7ea79ffb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">performing basic regression to fit a line for left lane and  <a href="#a70feae4d9119d7288b54bd7ea79ffb47">More...</a><br /></td></tr>
<tr class="separator:a70feae4d9119d7288b54bd7ea79ffb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a1c156b23a87158f1460df8544b118"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlanedetector.html#a98a1c156b23a87158f1460df8544b118">predictTurn</a> ()</td></tr>
<tr class="memdesc:a98a1c156b23a87158f1460df8544b118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts turn based on the location of the vanishing point. Vanishing.  <a href="#a98a1c156b23a87158f1460df8544b118">More...</a><br /></td></tr>
<tr class="separator:a98a1c156b23a87158f1460df8544b118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac600737bb1e17700b37abdfd9bb73b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lanedetector::lanedetector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the private members of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a968acbf150b7e935953c340a2cf38542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lanedetector::lanedetector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_leftLaneF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_rightLaneF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_leftSlope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_rightSlope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>_leftBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>_rightBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_imgCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_vanPtThresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the private members of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftLaneF</td><td>flag for if left lane was detected </td></tr>
    <tr><td class="paramname">rightLaneF</td><td>flag for if right lane was detected </td></tr>
    <tr><td class="paramname">leftSlope</td><td>stores value of computed slope of left lane </td></tr>
    <tr><td class="paramname">rightSlope</td><td>stores value of computed slope of right lane </td></tr>
    <tr><td class="paramname">leftBias</td><td>stores value of computed bias of left lane </td></tr>
    <tr><td class="paramname">rightBias</td><td>stores value of computed bias of right lane </td></tr>
    <tr><td class="paramname">imgCenter</td><td>stores value of image center to localise vanishing point </td></tr>
    <tr><td class="paramname">vanPtThresh</td><td>threshold for vanishing point to predict turn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a70feae4d9119d7288b54bd7ea79ffb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Point &gt; lanedetector::computeFitLine </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Vec4i &gt;&gt;&#160;</td>
          <td class="paramname"><em>validLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performing basic regression to fit a line for left lane and </p>
<p>right lane from all the sorted lines output from sortLanes function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validLines</td><td>is a two dimensional vector of a four dimensional data structure </td></tr>
    <tr><td class="paramname">and</td><td>contains x and y coordinates of start and end points depicting a line </td></tr>
    <tr><td class="paramname">inpImg</td><td>is the input images on which the lines were computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of four points representing the final two lines for left </dd>
<dd>
and right respectively </dd></dl>

</div>
</div>
<a class="anchor" id="abea27c43dbcf8444f5c2b23dd6e4bb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::createMask </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask the image so that only a certain portion of the image has active. </p>
<p>contents, the rest are set to inactive region, say set to zero. This is similar to what extractROI is doing except that we retain the dimensions of the original image and only the region of interest is active. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image that we need to mask to bring out only a ROI </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>masked image with dimensions same as input image </dd></dl>

</div>
</div>
<a class="anchor" id="a8830dfaa616e20b5e15f8846fa8660eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::detectEdges </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect edges in an gray scale image. Since the ultimate objective. </p>
<p>is to detect lanes, it is easier and efficient to compute straight lines from edges extracted from an image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is a grayscale image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image with extracted edges </dd></dl>

</div>
</div>
<a class="anchor" id="a10d588d6b85384ad237e6fbfdf679591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Vec4i &gt; lanedetector::detectLanes </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detects straight lines in a given image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the image from which we need to detect straight lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of a four dimensional data structure which holds the </dd>
<dd>
x and y coordinates of the start and end point of a line </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7506555f481f184276a4180c200a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::drawLines </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4i &gt;&#160;</td>
          <td class="paramname"><em>lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for debugging. Draws lines on top of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image on top of which lines will be drawn </td></tr>
    <tr><td class="paramname">lines</td><td>is a vector of four dimensional data structure and contains </td></tr>
    <tr><td class="paramname">x</td><td>and y coordinates of start and end points depicting a line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input image with overlayed lines </dd></dl>

</div>
</div>
<a class="anchor" id="a714784d2ef657578c3b8bbef5aeb3dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::drawLines </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4i &gt;&#160;</td>
          <td class="paramname"><em>leftLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4i &gt;&#160;</td>
          <td class="paramname"><em>rightLines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for debugging. Draws lines on top of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image on top of which lines will be drawn </td></tr>
    <tr><td class="paramname">leftLines</td><td>is a vector of four dimensional data structure and contains </td></tr>
    <tr><td class="paramname">x</td><td>and y coordinates of start and end points depicting a line </td></tr>
    <tr><td class="paramname">rightLines</td><td>is a vector of four dimensional data structure and contains </td></tr>
    <tr><td class="paramname">x</td><td>and y coordinates of start and end points depicting a line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input image with overlayed lines </dd></dl>

</div>
</div>
<a class="anchor" id="a03607a04461f6f9137a2d97297266d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lanedetector::drawPolygon </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point &gt;&#160;</td>
          <td class="paramname"><em>finalPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>turn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augments the detected lane with a colored polygon for better. </p>
<p>visualization. Also adds text received from the predictTurn function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image which will be overlayed with the augmented box </td></tr>
    <tr><td class="paramname">finalPoly</td><td>is the set (or vector) of points depicting the final polygon </td></tr>
    <tr><td class="paramname">computed</td><td>from the left and right lane </td></tr>
    <tr><td class="paramname">turn</td><td>is the output that was extracted from predictTurn function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ab82eab5e0a1d126018c99875b2486d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::extractROI </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Rect&#160;</td>
          <td class="paramname"><em>rectRoi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract a region of interest from an image </p>
<p>similar to cropping a region of interest from an image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image from which we wish to extract a ROI </td></tr>
    <tr><td class="paramname">rectRoi</td><td>is an object of the type cv::Rect and is essentially just </td></tr>
    <tr><td class="paramname">a</td><td>set of four points which we will use as vertices for extracting </td></tr>
    <tr><td class="paramname">the</td><td>region of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an image which has been extracted from the input image </dd></dl>

</div>
</div>
<a class="anchor" id="a90b977cb614d19ffa5e56f1b3ef3e8c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::grayImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert a BGR image (three channels) to grayscale (single channel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>that needs to be converted to grayscale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>grayscale image </dd></dl>

</div>
</div>
<a class="anchor" id="a6433369cb584d5c247fe1a00569d17d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::perspectiveTransform </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warping an image to get a top view or bird's eye view. To improve. </p>
<p>accuracy of detecting straight lines we can project the ROI with lanes in the bird's eye view. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image which needs to projected in top view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>warped image (in the top view) </dd></dl>

</div>
</div>
<a class="anchor" id="a98a1c156b23a87158f1460df8544b118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string lanedetector::predictTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicts turn based on the location of the vanishing point. Vanishing. </p>
<p>point is computed by finding the intersection of the final left lane and right lane </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>direction of predicted turn, "Left", "Straight" or "Right" </dd></dl>

</div>
</div>
<a class="anchor" id="a4d92c01545c5c9713c9a70d5903ce181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::preprocessImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denoise or smoothen image by applying a Gaussian filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image which needs to be smoothened </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blurred or smooth image after denoising </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9086075ddbe4827f473ce7105c1c27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; cv::Vec4i &gt; &gt; lanedetector::sortLanes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec4i &gt;&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects only valid lines from all detected lines and sorts them. </p>
<p>into potentially left lane or right lane based on their slope </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lines</td><td>is a vector of four dimensional data structure and contains </td></tr>
    <tr><td class="paramname">x</td><td>and y coordinates of start and end points depicting a line </td></tr>
    <tr><td class="paramname">inpImg</td><td>is the input image from which these lines have been calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a two dimensional vector of a four dimensional data structure and contains </dd>
<dd>
x and y coordinates of start and end points depicting a line </dd></dl>

</div>
</div>
<a class="anchor" id="ae1c096187d507d6f3e623b9c7a471459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat lanedetector::undistortImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>inpImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>cameraMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>distCoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Due to radial distortion, straight lines appear as curved. </p>
<p>This function undistorts the input image provided the intrinsic camera paramters. OpenCV provides an inbuilt function to perform this operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inpImg</td><td>is the input image that needs to be un distorted </td></tr>
    <tr><td class="paramname">cameraMatrix</td><td>is an intrinsic camera parameter with focal length </td></tr>
    <tr><td class="paramname">and</td><td>optical center values </td></tr>
    <tr><td class="paramname">distCoeff</td><td>are the distortion coefficients and are required to </td></tr>
    <tr><td class="paramname">undistort</td><td>the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>undistorted image </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sarthak/fall18/808x/code/advanced-lane-detection/include/<a class="el" href="lanedetector_8h_source.html">lanedetector.h</a></li>
<li>/home/sarthak/fall18/808x/code/advanced-lane-detection/app/<a class="el" href="lanedetector_8cpp.html">lanedetector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
